I will extract the display configuration and implementation from `src/board/m5stack/core-s3.cpp` and `src/board/m5stack/core-s3.hpp` and refactor it to use the `SpiDisplay` class from `src/wrapper/display.hpp`.

**1. Create** **`src/device/ili9341.hpp`**

*   Define the `Ili9341` class, inheriting from `SpiDisplay`.
*   Include necessary headers.
*   Define default configuration constants if applicable (though `core-s3.cpp` has specific configs).

**2. Create** **`src/device/ili9341.cpp`**

*   Implement the `Ili9341` class methods.
*   Since `SpiDisplay` is already a generic wrapper, `Ili9341` might just be a type alias or a thin wrapper if specific initialization sequences are needed beyond what `esp_lcd_new_panel_ili9341` provides.
*   *Correction*: Looking at `core-s3.cpp`, it uses `SpiDisplay ili9341(logger_ili9341, spi_bus);` directly. The user wants to *encapsulate* this.
*   The user's request is to "extract display code and config... using `wrapper/display.hpp`".
*   Currently `core-s3.cpp` *already* uses `SpiDisplay`.
*   However, `src/device/ili9341.hpp` is currently empty (0 bytes) as per previous context.
*   I will move the specific logic (like the specific `SpiDisplayConfig` values) into a dedicated `Ili9341` class in `src/device/ili9341.{hpp,cpp}` to clean up `core-s3.cpp`.

**3. Refactor** **`src/board/m5stack/core-s3.cpp`**

*   Remove the raw `SpiDisplayConfig spi_lcd_config` definition.
*   Include `device/ili9341.hpp`.
*   Replace `SpiDisplay ili9341` with `Ili9341 display` (or keep name `ili9341` but use the new class).
*   Update `InitDevice` to use the new class.

**Detailed Plan:**

1.  **Analyze `core-s3.cpp`**:
    *   It defines `SpiDisplayConfig spi_lcd_config` with specific pins (CS=3, DC=35, Speed=40MHz) and panel config (BGR, Big Endian, 16bpp).
    *   It initializes `ili9341` using `ili9341.Init(spi_lcd_config, esp_lcd_new_panel_ili9341)`.

2.  **Implementation Strategy**:
    *   **`src/device/ili9341.hpp`**:
        *   Class `Ili9341 : public wrapper::SpiDisplay`
        *   Constructor taking `Logger&` and `SpiBus&`.
        *   Method `Init()` that internally sets up the specific config and calls `SpiDisplay::Init`.
    *   **`src/device/ili9341.cpp`**:
        *   Implement `Init`.

3.  **Update `core-s3`**:
    *   Use the new `Ili9341` class.

**Wait**, the `Ili9341` class in `device` should probably be a generic ILI9341 driver *if* it wasn't already provided by ESP-IDF. But here ESP-IDF provides the panel driver. The "Device" here usually refers to a specific component on the board.
Actually, the user wants to "extract code and config".
So I will create `src/device/ili9341.hpp` to act as a specialized driver that pre-defines the `esp_lcd_new_panel_ili9341` callback and potentially default configs, *or* just use it to hold the board-specific config if that's what the user implies.
But usually, `device/` contains reusable drivers. The config (pins) is board-specific.
However, `core-s3.cpp` has the config hardcoded.
I will assume the goal is to make `Ili9341` a reusable component class that *can* be configured, but maybe simplifies the `Init` call.

**Revised Plan**:
1.  **Modify `src/device/ili9341.hpp`**:
    *   Inherit from `wrapper::SpiDisplay`.
    *   Add `Init(const wrapper::SpiDisplayConfig& config)`.
2.  **Modify `src/device/ili9341.cpp`**:
    *   Implement `Init` which calls `SpiDisplay::Init` passing `esp_lcd_new_panel_ili9341`.
3.  **Modify `src/board/m5stack/core-s3.hpp`**:
    *   Change member type if necessary (it's currently `SpiDisplay`).
4.  **Modify `src/board/m5stack/core-s3.cpp`**:
    *   Update `spi_lcd_config` to be cleaner or moved if requested, but primarily ensure `ili9341` uses the new `device/ili9341.hpp` class if I change the type.
    *   Actually, `SpiDisplay` is generic. `Ili9341` is specific.
    *   I will change `SpiDisplay ili9341` to `Ili9341 ili9341`.

Let's do this.

*   `src/device/ili9341.hpp`:
    ```cpp
    #pragma once
    #include "wrapper/display.hpp"
    #include "esp_lcd_ili9341.h"

    namespace wrapper {
    class Ili9341 : public SpiDisplay {
    public:
        using SpiDisplay::SpiDisplay; // Inherit constructor
        bool Init(const SpiDisplayConfig& config);
    };
    }
    ```
*   `src/device/ili9341.cpp`:
    ```cpp
    #include "ili9341.hpp"

    namespace wrapper {
    bool Ili9341::Init(const SpiDisplayConfig& config) {
        return SpiDisplay::Init(config, esp_lcd_new_panel_ili9341);
    }
    }
    ```
*   `src/board/m5stack/core-s3.cpp`:
    *   Include `device/ili9341.hpp`.
    *   Change definition `SpiDisplay ili9341` -> `Ili9341 ili9341`.
    *   Simplify Init call: `ili9341.Init(spi_lcd_config)`.

This seems to match the "encapsulation" intent.

**Files to modify/create:**
1.  `src/device/ili9341.hpp`
2.  `src/device/ili9341.cpp`
3.  `src/board/m5stack/core-s3.cpp`
4.  `src/board/m5stack/core-s3.hpp` (if `ili9341` is exposed there? No, `core-s3.hpp` only exposes getters, `SpiDisplay&` return type is fine or can be updated to `Ili9341&` if we want to be specific, but `DisplayBase&` or `SpiDisplay&` is more polymorphic. I'll check `core-s3.hpp` again - it doesn't expose the display object directly in `public`, only via `AddDisplay` in `lvgl_port`. Wait, `core-s3.hpp` *does* not seem to have a getter for display?
    *   Checking `core-s3.hpp`: It has `GetI2cBus1`, `GetSpiBus`, `GetPowerManagement`, `GetGpioExpander`, `GetLvglPort`, `GetAudioCodec`. It does **not** expose `ili9341`.
    *   So I only need to touch `core-s3.cpp`.

Wait, `core-s3.cpp` line 393: `lvgl_port.AddDisplay(ili9341, ...)`
And line 218: `SpiDisplay ili9341(logger_ili9341, spi_bus);` is a global/static variable in the anonymous namespace or just file scope.

I will proceed.