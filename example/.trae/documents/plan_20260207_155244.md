I need to refactor the configuration initialization in `src/app/main/app_main.cpp` for the M5Stack Cardputer. The previous implementation used aggregate initialization (struct assignment), but the project rules (`wrapper-esp32.md`) explicitly state to use **constructor initialization** for Config structs, following the pattern in the wrappers.

I also need to check the constructors of `SpiBusConfig`, `SpiDisplayConfig`, `I2cBusConfig`, etc., to ensure I pass the correct arguments.

**1. Check Config Struct Constructors**

*   **`SpiBusConfig` (from `wrapper/spi.hpp`)**:
    ```cpp
    SpiBusConfig(spi_host_device_t host, int mosi, int miso, int sclk, ... many defaults ...);
    ```
    I need to use this constructor.
*   **`SpiDisplayConfig` (from `wrapper/display.hpp`)**:
    ```cpp
    SpiDisplayConfig(int cs_gpio, int dc_gpio, int spi_mode, int clock_speed_hz, ...);
    ```
    I need to use this constructor.
*   **`I2cBusConfig` (from `wrapper/i2c.hpp`)**:
    ```cpp
    I2cBusConfig(i2c_port_t port, gpio_num_t sda, gpio_num_t scl, i2c_clock_source_t clk_src, ...);
    ```
    I need to use this constructor.
*   **`I2sBusConfig` & `I2sChanStdConfig` (from `wrapper/i2s.hpp`)**:
    Already using constructors in the current `app_main.cpp`, so they are fine, just need to verify parameters.

**2. Modify `app_main.cpp`**

*   Refactor `spi_bus_config` to use `SpiBusConfig(...)`.
*   Refactor `spi_display_config` to use `SpiDisplayConfig(...)`.
*   Refactor `i2c_bus_config` to use `I2cBusConfig(...)`.
*   (I2S configs are already using constructors, but I will double check the arguments).

**Details for Constructors:**

*   **`SpiBusConfig`**:
    *   `host`: `SPI2_HOST`
    *   `mosi`: `GPIO_NUM_35`
    *   `miso`: `GPIO_NUM_NC`
    *   `sclk`: `GPIO_NUM_36`
    *   ... (defaults for others: quadwp=-1, quadhd=-1, data4-7=-1, level=true, max_trans=4096, flags=SPICOMMON_BUSFLAG_MASTER, isr=AUTO, intr=0, dma=SPI_DMA_CH_AUTO)
*   **`SpiDisplayConfig`**:
    *   `cs`: `GPIO_NUM_37`
    *   `dc`: `GPIO_NUM_34`
    *   `mode`: `0`
    *   `speed`: `40000000`
    *   `cmd_bits`: `8` (default)
    *   `param_bits`: `8` (default)
    *   `queue`: `10`
    *   ... (defaults)
    *   `reset`: `GPIO_NUM_33` (This is a named parameter late in the list, or need to see where it fits).
    *   Checking `wrapper/display.hpp` again (from previous context):
        ```cpp
        SpiDisplayConfig(
            int cs_gpio, int dc_gpio, int spi_mode, int clock_speed_hz,
            int lcd_cmd_bits, int lcd_param_bits,
            size_t trans_queue_depth = 10,
            ...
            gpio_num_t reset_gpio = GPIO_NUM_NC,
            ...
        )
        ```
        So I need to provide `cmd_bits` and `param_bits` explicitly (8, 8) before `queue`. And `reset_gpio` is further down. I'll need to pass defaults for intervening args or rely on defaults if they are at the end? `reset_gpio` is after `cs_high_active`. I need to pass many defaults to get to `reset_gpio` or just use the defaults and set `reset_gpio` field manually after construction if it's public? Struct members are public.
        **Strategy**: Use constructor for main fields, and if the constructor has too many params before the one I want, I can construct it and then set the specific field if the struct definition allows (it inherits from `esp_lcd_...` and has members). But the rule says "use constructor".
        I will look at the `SpiDisplayConfig` constructor again. It has many parameters with defaults. `reset_gpio` is the 19th parameter.
        `io_config` params... `panel_config` params start at `reset_gpio`.
        So I have to provide all `io_config` params to reach `panel_config` params?
        Let's count:
        1. cs, 2. dc, 3. mode, 4. speed, 5. cmd_bits, 6. param_bits (NO DEFAULT)
        7. queue (default 10)
        8. on_color (default null)
        9. user_ctx (default null)
        10. pre (0), 11. post (0)
        12-19 flags (defaults 0)
        20. reset_gpio (default NC)
        This is painful to call with all defaults.
        **Alternative**: The rule says "construct xxxConfig struct, ... use constructor". It doesn't strictly forbid setting members if the constructor is unwieldy, but implies using the constructor is the "correct" way.
        I will try to use the constructor as much as reasonable, or maybe the rule implies "don't just use `{ .field = val }` aggregate initialization for complex wrappers".
        I will use the constructor for the required first 6 args, and defaults for the rest, and maybe update `reset_gpio` manually if I don't want to pass 15 `0`s. Or I will just pass them. It's cleaner to be explicit if I'm following the rule strictly.

*   **`I2cBusConfig`**:
    *   `port`, `sda`, `scl`, `clk_src`, `glitch`, `intr_prio`, `queue`, `pullup`, `pd`.
    *   All these seem to be in the constructor signature I saw earlier.

Let's apply this refactoring.