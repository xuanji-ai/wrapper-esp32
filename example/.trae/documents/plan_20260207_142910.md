I will extract the ILI9881C display code and configuration from `src/board/m5stack/tab5.cpp` and refactor it into a new class `Ili9881c` in `src/device/ili9881c.hpp` and `src/device/ili9881c.cpp`, inheriting from `DsiDisplay`.

**1. Create** **`src/device/ili9881c.hpp`**

*   Define the `Ili9881c` class, inheriting from `wrapper::DsiDisplay`.
*   Include necessary headers.
*   Expose an `Init` method that takes `DsiBus` and `DsiDisplayConfig`.

**2. Create** **`src/device/ili9881c.cpp`**

*   Move the `m5tab5_disp_init_data` array (initialization commands) from `tab5.cpp` to this file (or keep it as static data within the class/file).
*   Implement `Init`:
    *   Set up the `ili9881c_vendor_config_t`.
    *   Call `DsiDisplay::Init` with `esp_lcd_new_panel_ili9881c`.

**3. Refactor** **`src/board/m5stack/tab5.cpp`**

*   Include `device/ili9881c.hpp`.
*   Remove the raw `m5tab5_disp_init_data` and `ili9881c_vendor_config_t dsi_vendor_cfg`.
*   Replace `DsiDisplay dsi_display` with `Ili9881c dsi_display`.
*   Update `Init` to use the new class.

**4. Refactor** **`src/board/m5stack/tab5.hpp`**

*   Update `GetDsiDisplay` return type (optional, can return reference to base or derived, I'll keep it as `DsiDisplay&` or update to `Ili9881c&` depending on usage). Since `DsiDisplay` is the wrapper base, it might be safer to keep `DsiDisplay&` in the getter if we want polymorphism, but usually specific getters return the specific type. I'll update it to `Ili9881c&` for consistency with the CoreS3 refactor.

**Note:** `DsiDisplay` in `display-dsi.hpp` seems to have `Init` returning `esp_err_t`. I should probably update `Ili9881c::Init` to return `bool` to match the recent refactoring trend, handling the error internally.

**Wait**, `DsiDisplay` itself returns `esp_err_t` in `Init`. I should probably follow the pattern of the base class or wrap it. Since the previous task refactored `Ili9341` (SpiDisplay) to return `bool` and `SpiDisplay::Init` returned `bool`, I should check if `DsiDisplay::Init` returns `bool`.
Checking `src/wrapper/display-dsi.hpp`:
```cpp
    esp_err_t Init(
      const DsiBus& bus,
      const DsiDisplayConfig& config,
      ...
    );
```
It returns `esp_err_t`. I should probably wrap this in `Ili9881c::Init` to return `bool` and log errors, consistent with other device drivers.

**Plan details:**
1.  **`src/device/ili9881c.hpp`**: Class definition.
2.  **`src/device/ili9881c.cpp`**: Implementation with init commands.
3.  **`src/board/m5stack/tab5.cpp`**: Use the new class.
4.  **`src/board/m5stack/tab5.hpp`**: Update getter return type.

I will also need to handle the `dsi_vendor_cfg` setup which involves a lambda for runtime configuration of `dsi_bus` and `dpi_config`. The new `Ili9881c::Init` should handle this internally.

**Specific implementation detail for `Ili9881c::Init`**:
It needs to take `DsiBus& bus` and `DsiDisplayConfig& config`.
It will create the `vendor_config` internally (as a member or local static if it needs to persist? `esp_lcd_new_panel_ili9881c` likely copies it or needs it to persist? The `vendor_config` pointer is passed to `new_panel`. Usually these configs are struct copies, but `ili9881c_vendor_config_t` has pointers. I need to be careful.
`m5tab5_disp_init_data` is static const data, that's fine.
`dsi_vendor_cfg` struct itself...
In `tab5.cpp`, it was a member variable.
I will make `dsi_vendor_cfg` a member of `Ili9881c` to ensure it persists if needed, or check if the driver copies it. `esp_lcd_new_panel_ili9881c` takes `const esp_lcd_panel_dev_config_t *panel_dev_config`. The `vendor_config` is part of `panel_dev_config`.
I will define `ili9881c_vendor_config_t` as a member of `Ili9881c`.

Let's proceed.