I have analyzed the `todo/powerhub` code and the `wrapper-esp32` library. I found that `wrapper-esp32` provides an `I2cDevice` class that encapsulates I2C operations, which is suitable for porting the `PowerHub` driver.

I propose the following plan to port the code and implement storage:

1.  **Port `PowerHub` Driver**:
    *   Create `wrapper-esp32/src/board/m5stack/powerhub.hpp` and `.cpp`.
    *   Define the `PowerHub` class within `namespace wrapper`, inheriting from `wrapper::I2cDevice`.
    *   Adapt the API to match the wrapper style (e.g., `Init` instead of `begin`, using `wrapper::Logger`).
    *   Replace direct `i2c_bus` calls with `I2cDevice` methods (`WriteReg8`, `ReadRegBytes`, etc.).

2.  **Implement Storage (NVS)**:
    *   Since the user requested "implement storage to device", and the PowerHub registers are volatile, I will implement persistence using the ESP32's NVS (Non-Volatile Storage).
    *   Add `SaveConfig()` and `LoadConfig()` methods to the `PowerHub` class.
    *   These methods will save/load critical settings (like LED colors, Bus Config, etc.) to/from NVS using the `nvs_flash` component, allowing settings to survive reboots.

3.  **Update Build System**:
    *   Modify `wrapper-esp32/example/wrapper-esp32/CMakeLists.txt` to include the new `powerhub.cpp` file in the build.

This approach fully utilizes the `wrapper-esp32` encapsulation and fulfills the storage requirement.